#!/usr/bin/env ruby

require 'rubygems'
require 'json'
require 'RMagick'
include Magick

$snapshot = 'chaos.sna'

class ChaosSnapshot
  ATTRIBUTES = [
    ['#000000', '#0000cd', '#cd0000', '#cd00cd', '#00cd00', '#00cdcd', '#cdcd00', '#cdcdcd'],
    ['#000000', '#0000ff', '#ff0000', '#ff00ff', '#00ff00', '#00ffff', '#ffff00', '#ffffff']
  ]
  
  def initialize(filename)
    @lookup = Array.new(16384 - 27)
    File.open(filename, "r") do |file|
      while !file.eof? do
        @lookup << file.readbyte
      end
    end
  end
  
  def each_chaos_object
    (0xe3e2..0xe43e).step(2) do |location|
      yield lookup_data_table((location - 0xe3De) / 2, address(location))
    end
  end
  
  def characters
    2.times do |bright_index|
      (1..7).each do |ink_index|
        letters = Array.new
        (0xd908..0xDC00).step(8) do |location|
          letters << render_frame(char_bytes(location), ATTRIBUTES[bright_index][ink_index])
        end
        yield letters, (bright_index * 8 + ink_index)
      end
    end
  end
  
  def each_object_sprite
    output = Hash.new
    each_chaos_object do |object|
      anim = Magick::ImageList.new
      object[:frames].each_with_index do |frame, num|
        anim << render_frame(frame[:bytes], frame[:attribute][:ink], frame[:attribute][:paper])
      end
      anim.ticks_per_second = 50
      anim.delay = object[:frame_timing]
      yield(object[:name], anim, object[:corpse] ? render_frame(object[:corpse][:bytes], object[:corpse][:attribute][:ink], object[:corpse][:attribute][:paper]) : nil) unless object[:wizard]
    end
  end
  
  def each_wizard_sprite
    each_chaos_object do |object|
      if object[:wizard]
        2.times do |bright_index|
          (1..7).each do |ink_index|
            anim = Magick::ImageList.new
            object[:frames].each_with_index do |frame, num|
              anim << render_frame(frame[:bytes], ATTRIBUTES[bright_index][ink_index])
            end
            anim.ticks_per_second = 50
            anim.delay = object[:frame_timing]
            yield(object[:name], (bright_index * 8 + ink_index), anim) if object[:wizard]
          end
        end
      end
    end
  end
  
  def each_weapon_sprite
    wizard_timing =  @lookup[address(0xe430) + 22]
    2.times do |bright_index|
      (1..7).each do |ink_index|
        ink = bright_index * 8 + ink_index
        anim = Magick::ImageList.new
        (0x8290..0x8296).step(2) do |location|
          anim << render_frame(gfx_bytes(address(location)), ATTRIBUTES[bright_index][ink_index])
        end
        anim.ticks_per_second = 50
        anim.delay = wizard_timing
        yield 'MAGIC SWORD', ink, anim
        anim = Magick::ImageList.new
        (0x8298..0x829e).step(2) do |location|
          anim << render_frame(gfx_bytes(address(location)), ATTRIBUTES[bright_index][ink_index])
        end
        anim.ticks_per_second = 50
        anim.delay = wizard_timing
        yield 'MAGIC KNIFE', ink, anim
        anim = Magick::ImageList.new
        (0x82A0..0x82a6).step(2) do |location|
          anim << render_frame(gfx_bytes(address(location)), ATTRIBUTES[bright_index][ink_index])
        end
        anim.ticks_per_second = 50
        anim.delay = wizard_timing
        yield 'MAGIC ARMOUR', ink, anim
        anim = Magick::ImageList.new
        (0x82A8..0x82Ae).step(2) do |location|
          anim << render_frame(gfx_bytes(address(location)), ATTRIBUTES[bright_index][ink_index])
        end
        anim.ticks_per_second = 50
        anim.delay = wizard_timing
        yield 'MAGIC SHIELD', ink, anim
        anim = Magick::ImageList.new
        (0x82b0..0x82b6).step(2) do |location|
          anim << render_frame(gfx_bytes(address(location)), ATTRIBUTES[bright_index][ink_index])
        end
        anim.ticks_per_second = 50
        anim.delay = wizard_timing
        yield 'MAGIC WINGS', ink, anim
        anim = Magick::ImageList.new
        (0x82b8..0x82Be).step(2) do |location|
          anim << render_frame(gfx_bytes(address(location)), ATTRIBUTES[bright_index][ink_index])
        end
        anim.ticks_per_second = 50
        anim.delay = wizard_timing
        yield 'MAGIC BOW', ink, anim
      end
    end
  end
  
  private
  
  def render_frame(bytes, ink = nil, paper = nil)
    img = Image.new(bytes.first.length, bytes.length)
    bytes.each_with_index do |line, y|
      line.split(//).each_with_index do |bit, x|
        img = img.color_point(x, y, (bit == '1') ? (ink || ATTRIBUTES[1][7]) : (paper || ATTRIBUTES[1][0]))
      end
    end
    img.scale(2)
  end
  
  def address(location)
    (@lookup[location + 1] << 8) + @lookup[location]
  end
  
  def text(location, length)
    output = String.new
    length.times do |num|
      output += @lookup[location + num].chr
    end
    output.strip
  end
  
  def attribute(location)
    bin = @lookup[location].chr.unpack('B8').first
    bright = bin[1, 1].to_i(2)
    {
      :paper => ATTRIBUTES[bright][bin[2, 3].to_i(2)],
      :ink => ATTRIBUTES[bright][bin[5, 3].to_i(2)]
    }
  end
  
  def char_bytes(location)
    raw = Array.new
    output = Array.new
    8.times do |num|
      output << @lookup[location + num].chr.unpack("B8").first
    end
    8.times do |num|
      output << @lookup[location + 768 + num].chr.unpack("B8").first
    end
    output
  end
  
  def gfx_bytes(location)
    raw = Array.new
    output = Array.new
    32.times do |num|
      raw << @lookup[location + num].chr.unpack('B8').first
    end
    8.times do |num|
      output << raw[num] + raw[num + 8]
    end
    8.times do |num|
      output << raw[num + 16] + raw[num + 24]
    end
    output
  end
  
  def gfx(location)
    {
      :bytes => gfx_bytes(address(location)),
      :attribute => attribute(location + 2)
    }
  end
  
  def lookup_data_table(id, table_address)
    {
      :name => text(table_address, 13),
      :id => id,
      :combat => @lookup[table_address + 13],
      :ranged_combat => @lookup[table_address + 14],
      :range => @lookup[table_address + 15],
      :defence => @lookup[table_address + 16],
      :movement_allowance => @lookup[table_address + 17],
      :manoeuvre_rating => @lookup[table_address + 18],
      :magic_resistance => @lookup[table_address + 19],
      :casting_chance => @lookup[table_address + 20],
      :chaos_law_value => @lookup[table_address + 21].chr.unpack('c').first,
      :frame_timing => @lookup[table_address + 22],
      :frames => [
        gfx(table_address + 23),
        gfx(table_address + 26),
        gfx(table_address + 29),
        gfx(table_address + 32)
      ],
      :corpse => id < 28 ? gfx(table_address + 35) : nil,
      :mount => id > 15 && id < 22,
      :flying => id > 18 && id < 30,
      :undead => id > 27 && id < 34,
      :transparent => id == 29 || id == 31 || id == 35,
      :subvertable => id < @lookup[0x857B],
      :wizard => id > 40
    }
  end
end

def dump_sprites(snapshot)
  Dir.mkdir 'gfx' unless File.directory? 'gfx'
  Dir.mkdir 'gfx/objects' unless File.directory? 'gfx/objects'
  Dir.mkdir 'gfx/corpses' unless File.directory? 'gfx/corpses'
  Dir.mkdir 'gfx/wizards' unless File.directory? 'gfx/wizards'
  Dir.mkdir 'gfx/weapons' unless File.directory? 'gfx/weapons'
  Dir.mkdir 'gfx/character_set' unless File.directory? 'gfx/character_set'
  
  
  snapshot.each_object_sprite do |name, anim, corpse|
    print "Dumping #{name} sprite... "
    anim.write("gfx/objects/#{name}.gif")
    corpse.write("gfx/corpses/#{name}.gif") if corpse
    puts "done."
  end
  
  snapshot.each_wizard_sprite do |name, ink, anim|
    print "Dumping #{name} sprite (colour #{ink})... "
    path = "gfx/wizards/#{name}"
    Dir.mkdir path unless File.directory? path
    anim.write(path + "/#{ink}.gif")
    puts "done."
  end
  
  snapshot.each_weapon_sprite do |name, ink, anim|
    print "Dumping #{name} sprite (colour #{ink})... "
    path = "gfx/weapons/#{name}"
    Dir.mkdir path unless File.directory? path
    anim.write(path + "/#{ink}.gif")
    puts "done."
  end

  snapshot.characters do |letters, ink|
    print "Dumping character set sprite sheet (colour #{ink})... "
    img = Image.new(letters.first.columns * letters.length, letters.first.rows)
    letters.each_with_index do |letter, num|
      img.composite!(letter, num * letters.first.columns, 0, Magick::OverCompositeOp)
    end
    img.write("gfx/character_set/#{ink}.gif")
    puts "done."
  end
end

def dump_objects(snapshot)
  Dir.mkdir 'data' unless File.directory? 'data'
  
  data_table = Array.new
  
  snapshot.each_chaos_object do |object|
    data_table << object unless object[:wizard]
  end
  
  File.open('data/objects.json', 'w') do |file|
    print "Creating object data... "
    file.puts JSON.pretty_generate(data_table)
    puts "done."
  end
end

snapshot = ChaosSnapshot.new($snapshot)
dump_sprites(snapshot)
dump_objects(snapshot)